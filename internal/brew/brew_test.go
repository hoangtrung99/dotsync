package brew

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateBrewfile(t *testing.T) {
	info := &BrewInfo{
		Formulae: []string{"git", "go", "node"},
		Casks:    []string{"visual-studio-code", "docker"},
		Taps:     []string{"homebrew/bundle", "user/tap"},
	}

	content := GenerateBrewfile(info)

	// Check header
	if !strings.Contains(content, "# Brewfile generated by dotsync") {
		t.Error("Missing header")
	}

	// Check taps
	if !strings.Contains(content, `tap "homebrew/bundle"`) {
		t.Error("Missing tap entry")
	}

	// Check formulae
	if !strings.Contains(content, `brew "git"`) {
		t.Error("Missing brew entry for git")
	}
	if !strings.Contains(content, `brew "go"`) {
		t.Error("Missing brew entry for go")
	}

	// Check casks
	if !strings.Contains(content, `cask "visual-studio-code"`) {
		t.Error("Missing cask entry")
	}
}

func TestGenerateBrewfileEmpty(t *testing.T) {
	info := &BrewInfo{}

	content := GenerateBrewfile(info)

	// Should still have header
	if !strings.Contains(content, "# Brewfile generated by dotsync") {
		t.Error("Missing header")
	}

	// Should not have section headers for empty sections
	if strings.Contains(content, "# Formulae") {
		t.Error("Should not have Formulae section when empty")
	}
}

func TestGenerateBrewfileFormulaeOnly(t *testing.T) {
	info := &BrewInfo{
		Formulae: []string{"git", "neovim"},
	}

	content := GenerateBrewfile(info)

	if !strings.Contains(content, "# Formulae") {
		t.Error("Should have Formulae section")
	}
	if strings.Contains(content, "# Casks") {
		t.Error("Should not have Casks section when empty")
	}
	if strings.Contains(content, "# Taps") {
		t.Error("Should not have Taps section when empty")
	}
}

func TestGenerateBrewfileCasksOnly(t *testing.T) {
	info := &BrewInfo{
		Casks: []string{"firefox"},
	}

	content := GenerateBrewfile(info)

	if strings.Contains(content, "# Formulae") {
		t.Error("Should not have Formulae section when empty")
	}
	if !strings.Contains(content, "# Casks") {
		t.Error("Should have Casks section")
	}
	if !strings.Contains(content, `cask "firefox"`) {
		t.Error("Missing cask entry for firefox")
	}
}

func TestGenerateBrewfileTapsOnly(t *testing.T) {
	info := &BrewInfo{
		Taps: []string{"custom/tap"},
	}

	content := GenerateBrewfile(info)

	if !strings.Contains(content, "# Taps") {
		t.Error("Should have Taps section")
	}
	if !strings.Contains(content, `tap "custom/tap"`) {
		t.Error("Missing tap entry")
	}
}

func TestStats(t *testing.T) {
	info := &BrewInfo{
		Formulae: []string{"git", "go"},
		Casks:    []string{"vscode"},
		Taps:     []string{"tap1", "tap2", "tap3"},
	}

	f, c, taps := info.Stats()

	if f != 2 {
		t.Errorf("Expected 2 formulae, got %d", f)
	}
	if c != 1 {
		t.Errorf("Expected 1 cask, got %d", c)
	}
	if taps != 3 {
		t.Errorf("Expected 3 taps, got %d", taps)
	}
}

func TestStatsEmpty(t *testing.T) {
	info := &BrewInfo{}

	f, c, taps := info.Stats()

	if f != 0 {
		t.Errorf("Expected 0 formulae, got %d", f)
	}
	if c != 0 {
		t.Errorf("Expected 0 casks, got %d", c)
	}
	if taps != 0 {
		t.Errorf("Expected 0 taps, got %d", taps)
	}
}

func TestExportBrewfile(t *testing.T) {
	// Create temp directory
	tmpDir := t.TempDir()

	// Create a mock by testing just the file writing logic
	info := &BrewInfo{
		Formulae: []string{"git"},
	}

	content := GenerateBrewfile(info)

	// Test directory creation and file writing
	brewDir := filepath.Join(tmpDir, "homebrew")

	if err := os.MkdirAll(brewDir, 0755); err != nil {
		t.Fatalf("Failed to create directory: %v", err)
	}

	path := filepath.Join(brewDir, "Brewfile")
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write file: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(path); os.IsNotExist(err) {
		t.Error("Brewfile was not created")
	}

	// Verify content
	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("Failed to read file: %v", err)
	}

	if !strings.Contains(string(data), `brew "git"`) {
		t.Error("File content incorrect")
	}
}

func TestGetInstalledPackages(t *testing.T) {
	// Skip if brew is not installed
	if _, err := exec.LookPath("brew"); err != nil {
		t.Skip("brew not found, skipping integration test")
	}

	info, err := GetInstalledPackages()
	if err != nil {
		t.Fatalf("GetInstalledPackages failed: %v", err)
	}

	// Should have at least brew itself and some common packages if brew works
	// Just verify the structure is valid
	if info == nil {
		t.Error("Expected non-nil BrewInfo")
	}

	// Verify slices are initialized (not nil)
	if info.Formulae == nil && info.Casks == nil && info.Taps == nil {
		// All can be nil if nothing is installed, that's fine
	}
}

func TestExportBrewfileIntegration(t *testing.T) {
	// Skip if brew is not installed
	if _, err := exec.LookPath("brew"); err != nil {
		t.Skip("brew not found, skipping integration test")
	}

	tmpDir := t.TempDir()

	path, err := ExportBrewfile(tmpDir)
	if err != nil {
		// May fail if no packages are installed
		if strings.Contains(err.Error(), "no packages found") {
			t.Skip("No brew packages found, skipping")
		}
		t.Fatalf("ExportBrewfile failed: %v", err)
	}

	// Verify file was created
	if _, err := os.Stat(path); os.IsNotExist(err) {
		t.Error("Brewfile was not created")
	}

	// Verify content is valid
	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("Failed to read Brewfile: %v", err)
	}

	if !strings.Contains(string(data), "# Brewfile generated by dotsync") {
		t.Error("Invalid Brewfile content")
	}
}
