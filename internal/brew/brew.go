package brew

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// BrewInfo contains information about Homebrew packages
type BrewInfo struct {
	Formulae []string
	Casks    []string
	Taps     []string
}

// GetInstalledPackages returns all installed Homebrew packages
func GetInstalledPackages() (*BrewInfo, error) {
	info := &BrewInfo{}

	// Get formulae
	out, err := exec.Command("brew", "list", "--formula", "-1").Output()
	if err == nil {
		for _, pkg := range strings.Split(string(out), "\n") {
			pkg = strings.TrimSpace(pkg)
			if pkg != "" {
				info.Formulae = append(info.Formulae, pkg)
			}
		}
	}

	// Get casks
	out, err = exec.Command("brew", "list", "--cask", "-1").Output()
	if err == nil {
		for _, pkg := range strings.Split(string(out), "\n") {
			pkg = strings.TrimSpace(pkg)
			if pkg != "" {
				info.Casks = append(info.Casks, pkg)
			}
		}
	}

	// Get taps
	out, err = exec.Command("brew", "tap").Output()
	if err == nil {
		for _, tap := range strings.Split(string(out), "\n") {
			tap = strings.TrimSpace(tap)
			if tap != "" && !strings.HasPrefix(tap, "homebrew/core") && !strings.HasPrefix(tap, "homebrew/cask") {
				info.Taps = append(info.Taps, tap)
			}
		}
	}

	// Sort all lists
	sort.Strings(info.Formulae)
	sort.Strings(info.Casks)
	sort.Strings(info.Taps)

	return info, nil
}

// GenerateBrewfile generates a Brewfile content
func GenerateBrewfile(info *BrewInfo) string {
	var b strings.Builder

	b.WriteString("# Brewfile generated by dotsync\n")
	b.WriteString(fmt.Sprintf("# Generated at: %s\n", time.Now().Format("2006-01-02 15:04:05")))
	b.WriteString("# Install with: brew bundle install\n\n")

	// Taps
	if len(info.Taps) > 0 {
		b.WriteString("# Taps\n")
		for _, tap := range info.Taps {
			b.WriteString(fmt.Sprintf("tap \"%s\"\n", tap))
		}
		b.WriteString("\n")
	}

	// Formulae
	if len(info.Formulae) > 0 {
		b.WriteString("# Formulae\n")
		for _, formula := range info.Formulae {
			b.WriteString(fmt.Sprintf("brew \"%s\"\n", formula))
		}
		b.WriteString("\n")
	}

	// Casks
	if len(info.Casks) > 0 {
		b.WriteString("# Casks\n")
		for _, cask := range info.Casks {
			b.WriteString(fmt.Sprintf("cask \"%s\"\n", cask))
		}
	}

	return b.String()
}

// ExportBrewfile generates and saves a Brewfile to the specified directory
func ExportBrewfile(dir string) (string, error) {
	// Check if brew is available
	if _, err := exec.LookPath("brew"); err != nil {
		return "", fmt.Errorf("homebrew not found")
	}

	info, err := GetInstalledPackages()
	if err != nil {
		return "", fmt.Errorf("failed to get packages: %w", err)
	}

	if len(info.Formulae) == 0 && len(info.Casks) == 0 {
		return "", fmt.Errorf("no packages found")
	}

	content := GenerateBrewfile(info)

	// Ensure directory exists
	if err := os.MkdirAll(dir, 0755); err != nil {
		return "", fmt.Errorf("failed to create directory: %w", err)
	}

	// Write Brewfile
	path := filepath.Join(dir, "Brewfile")
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return "", fmt.Errorf("failed to write Brewfile: %w", err)
	}

	return path, nil
}

// Stats returns package counts
func (b *BrewInfo) Stats() (formulae, casks, taps int) {
	return len(b.Formulae), len(b.Casks), len(b.Taps)
}
